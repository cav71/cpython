#!/usr/bin/env python
"""parse the log generated by make and extract the gcc commands
use as:

    make > log
    extract-build-flags.py log

"""
import sys
import shlex
import argparse


class FakeGccParser(argparse.ArgumentParser):
    def __init__(self, *args, **kwargs):
        super(FakeGccParser, self).__init__(*args, **kwargs)
        self.add_argument('-c', action='store_true', dest='object')
        self.add_argument('-g', action='store_true', dest='debug')
        self.add_argument('-O', type=int, dest='optimize')
        self.add_argument('-W', dest='linkcmds', action='append')
        self.add_argument('-D', dest='defines', action='append')
        self.add_argument('-I', dest='includes', action='append')
        self.add_argument('-f', dest='flags', action='append')
        self.add_argument('-std', dest='standard')
        self.add_argument('-o', dest='output')
        self.add_argument('input')
        
    def parse_args(self, args=None, namespace=None):
        self.a = args
        return super(FakeGccParser, self).parse_args(args=args, namespace=namespace)

    def error(self, msg):
        return


def fakeparse(args):
    p = FakeGccParser()
    o = p.parse_args(args)
    return o


def readlines(fp):
    """itrates over lines potentiallly backslash terminated"""
    def issplit(l):
        return 1 if l.endswith('\\') else (2 if l.endswith('\\\n') else 0)
    def clean(l):
        r = l
        if issplit(l):
            r = l[:-issplit(l)]
        if r.endswith('\n'):
            r = r[:-1]
        if r.endswith('\r'):
            r = r[:-1]
        return r

    accrued = None
    for line in fp:
        if issplit(line):
            accrued = clean(line) if accrued is None else (accrued + clean(line))
        else:
            if accrued is None:
                yield clean(line)
            else:
                accrued += line
                yield clean(accrued)
                accrued = None


def collect_cmds(fp):
    result, failed = [], []
    for lineno, line in enumerate(readlines(fp)):
        try:
            # splits a line into tokens
            args = shlex.split(line)
        except:
            failed.append((lineno, 'parser-failure', line))
            continue
        # we gather all the line starting with gcc
        if not args or not 'gcc' in args[0]:
            failed.append((lineno, 'no-gcc-line', line))
            continue
        # we gather the options for the line, using a fake gcc-like parser
        options = fakeparse(args[1:])
        result.append(options)
    return result, failed

        
if __name__ == '__main__':
    p = argparse.ArgumentParser()
    p.add_argument('src', type=argparse.FileType('r'))
    o = p.parse_args()
    result, failed = collect_cmds(o.src)

    alldefines = set()
    for r in result:
        alldefines.update(r.defines or [])
    print('Defines')
    for d in sorted(alldefines):
        print(' {0}'.format(d))
